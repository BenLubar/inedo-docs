---
title: Docker Terminology & Concepts
sequence: 200
show-headings-in-nav: true
---

While Docker users rarely need to worry about the implementation details, these may become important when you manage and troubleshoot a private Docker registry.

Here's a brief guide to help familiarize yourself with basic Docker terminology and concepts.

**Registry**; a registry is a Docker feed in ProGet, but generally speaking it's a server that hosts Docker _repositories_ and related metadata. `registry-1.docker.io` and `mcr.microsoft.com` are also registries.

**Repository**; a repository is contained within a _registry_, and is essentially just the name of a container and a collection of _tags_. It's kind of like a package name. For example, `inedo/proget` and `dotnet/core` are repository names, but don't refer to a specific _image_.

**Image**; an image, or container image, is what many people think of when they say "container".  The Docker client downloads images from a _repository_ and runs an image as a _container_. Behind the scenes, an image is comprised of a _manifest_ and bunch of _layers_ described in that manifest. 

**Layer**; a layer is a .tar archive file (like a .zip file) that represents a "file system snapshot". By extracting a number of layers on top of each other (i.e. in the same directory), you end up with the file system that's used by a _container_. 

When you use the Docker client to build a container _image_, each command generates a new snapshot. Before running a container image, the Docker client assembles all of the layer files to make the file system.

Layers can be stored within the registry (as a _blob_), or they can be a _url_. Many Windows-based images use url-based layers, perhaps for licensing purposes.

**Blob**; blobs are the low-level storage mechanism in a _registry_, and they're essentially just files without a name. Instead of using filenames, blobs are accessed by their _digest (hash)_. This means humans really can't work with blobs, and you need a _tag_ or a _manifest_ to reference them in a meaningful manner.

Blobs are used to store _layers_ (.tar files) and _container configuration files_ (.json files). In Docker v1, blobs used to be used to store _manifests_ (.json files), but those are now stored separately.

**Digest (hash)**; digest and hash are generally synonymous in Docker terminology, and both refer to the SHA256-based hash of a _blob_. It's effectively the "filename" of a blob - but because it's automatically generated by the file's contents, it can never be changed.

**Tag**; this is how container images in a _repository_ are accessed by humans. Essentially it's a human-readable alias of the _digest (hash)_ of a _manifest_. Tags are not part of any image metadata themselves, they are purely a label provided by whatever repository their corresponding images are hosted in (whether it’s Docker client’s local repository, Docker Hub, ProGet, etc.).

For example, the tags `inedo/proget:5.3.1` and `inedo/proget:5.3.2-ci.4` would refer those container images.

A tag is formatted with two parts (`«image-name»:«tag»`), which can be a bit confusing because the second part of a tag is also called a tag. As such, tag (an alias of a manifest's digest) and tag (the second part of a tag) are often used interchangeably. 

In practice, tags (manifest digest aliases) are `«image-name»:«version-like-string»`, and the `«version-like-string»` can convention-driven words (like `latest` or `latest-v6`) or semantic versions.

**Manifest**. A manifest is a JSON document that lists all of the _layers_ of the _image_, which can be either _blobs_ or urls. It may contain the _digest_ for a _container configuration file_ in a "config" element.

Like everything else in Docker, manifests can only be found using a _digest (hash)_, even though they are not blobs. Practically, manifests are referenced by a _tag_, which provides the required digest.


**Container configuration file**. This is a JSON document that is stored as a _blob_, and is referenced via the "config" element of an image _manifest_. It's produced by the Docker client at build time, and contains metadata that's used to run the image, such as environment variables, exposed ports, operating system, etc. 

Container configuration files are optional, and not all container images will use them.

**Manifest list (fat manifest)**. A manifest list is a sort of "virtual" image that allows users to use a single _tag_ to refer to multiple container images for different architectures (such as AMD/Intel x64, or ARM, etc.).

A manifest list is a JSON document that lists *other* image _manifests_, along with their architectures. For example, the hypothetical tag `fatimg/java-jdk:5.2.1` could reference a _manifest list_ instead of a _manifest_. In that case, the Docker client would search the list for a compatible architecture (such as x64), and then follow the _digest_ to find the manifest file, and then start assembling the image.

**Dockerfile** is a code file that's written in a proprietary programming language. It's processed by the Docker client to construct an _image_ by creating file system snapshots after each command (these become _layers_), then building a _manifest_ and _container configuration file_.
